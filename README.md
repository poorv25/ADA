# ADA
Unit-1: Introduction to Algorithms:
Programming exercises related to implementing and analyzing the efficiency of
algorithms for common tasks such as searching and sorting, analyzing the performance
of different algorithms using big-O notation and empirical testing, and developing
algorithms for specific problems and evaluating their efficiency and effectiveness.
C Programming Exercises:
1. Implement a binary search algorithm for an array of integers.
2. Implement a bubble sort algorithm for an array of integers.
3. Implement a selection sort algorithm for an array of integers.
4. Implement an insertion sort algorithm for an array of integers.
5. Implement a merge sort algorithm for an array of integers.
6. Implement a quick sort algorithm for an array of integers.
7. Implement a linear search algorithm for an array of integers.
8. Implement a hash table data structure using separate chaining collision resolution.
9. Implement a hash table data structure using linear probing collision resolution.
10. Implement a heap data structure and use it to sort an array of integers.
Python Programming Exercises:
11. Implement a binary search algorithm for a list of integers.
12. Implement a bubble sort algorithm for a list of integers.
13. Implement a selection sort algorithm for a list of integers.
14. Implement an insertion sort algorithm for a list of integers.
15. Implement a merge sort algorithm for a list of integers.
16. Implement a quick sort algorithm for a list of integers.
17. Implement a linear search algorithm for a list of integers.
18. Implement a hash table data structure using separate chaining collision resolution.
19. Implement a hash table data structure using linear probing collision resolution.
20. Implement a heap data structure and use it to sort a list of integers.
Flowchart Exercises:
21. Create a flowchart for a binary search algorithm.
22. Create a flowchart for a bubble sort algorithm.
23. Create a flowchart for a selection sort algorithm.
24. Create a flowchart for an insertion sort algorithm.
25. Create a flowchart for a merge sort algorithm.
26. Create a flowchart for a quick sort algorithm.
27. Create a flowchart for a linear search algorithm.
28. Create a flowchart for a hash table data structure using separate chaining collision
resolution.
29. Create a flowchart for a hash table data structure using linear probing collision
resolution.
30. Create a flowchart for a heap data structure and use it to sort an array of integers.
These exercises can help you practice and develop your skills in implementing
and analyzing the efficiency of algorithms for common tasks such as searching and
sorting, analyzing the performance of different algorithms using big-O notation and
empirical testing, and developing algorithms for specific problems and evaluating their
efficiency and effectiveness.



Unit-2: Divide and Conquer:
Complete following programming exercises related to implementing and analyzing the
efficiency of divide-and-conquer algorithms for specific problems, developing new
divide-and-conquer algorithms for complex problems and evaluating their efficiency and
effectiveness, and comparing and contrasting divide-and-conquer algorithms with other
algorithmic approaches.
C Programming Exercises:
1. Implement a recursive algorithm for computing the factorial of a given positive
integer using divide-and-conquer.
2. Implement a recursive algorithm for computing the Fibonacci sequence using
divide-and-conquer.
3. Implement a recursive algorithm for computing the greatest common divisor of two
integers using divide-and-conquer.
4. Implement a recursive algorithm for computing the Euclidean distance between two
points in 2D space using divide-and-conquer.
5. Implement a divide-and-conquer algorithm for finding the maximum subarray sum of
a given array of integers.
6. Implement a divide-and-conquer algorithm for merging two sorted arrays.
7. Implement a divide-and-conquer algorithm for finding the kth largest element in an
unsorted array of integers.
8. Implement a divide-and-conquer algorithm for multiplying two large integers.
9. Implement a divide-and-conquer algorithm for finding the closest pair of points in 2D
space.
10. Implement a divide-and-conquer algorithm for sorting a linked list.
Python Programming Exercises:
11. Implement a recursive algorithm for computing the factorial of a given positive
integer using divide-and-conquer.
12. Implement a recursive algorithm for computing the Fibonacci sequence using
divide-and-conquer.
13. Implement a recursive algorithm for computing the greatest common divisor of two
integers using divide-and-conquer.
14. Implement a recursive algorithm for computing the Euclidean distance between two
points in 2D space using divide-and-conquer.
15. Implement a divide-and-conquer algorithm for finding the maximum subarray sum
of a given array of integers.
16. Implement a divide-and-conquer algorithm for merging two sorted arrays.
17. Implement a divide-and-conquer algorithm for finding the kth largest element in an
unsorted array of integers.
18. Implement a divide-and-conquer algorithm for multiplying two large integers.
19. Implement a divide-and-conquer algorithm for finding the closest pair of points in
2D space.
20. Implement a divide-and-conquer algorithm for sorting a linked list.
Flowchart Exercises:
21. Create a flowchart for a recursive algorithm for computing the factorial of a given
positive integer using divide-and-conquer.
22. Create a flowchart for a recursive algorithm for computing the Fibonacci sequence
using divide-and-conquer.
23. Create a flowchart for a recursive algorithm for computing the greatest common
divisor of two integers using divide-and-conquer.
24. Create a flowchart for a recursive algorithm for computing the Euclidean distance
between two points in 2D space using divide-and-conquer.
25. Create a flowchart for a divide-and-conquer algorithm for finding the maximum
subarray sum of a given array of integers.
26. Create a flowchart for a divide-and-conquer algorithm for merging two sorted arrays.
27. Create a flowchart for a divide-and-conquer algorithm for finding the kth largest
element in an unsorted array of integers.
28. Create a flowchart for a divide-and-conquer algorithm for multiplying two large
integers.
29. Create a flowchart for a divide-and-conquer algorithm for finding the closest pair of
points in 2D space.
30. Create a flowchart for a divide-and-conquer algorithm for sorting a linked list.
These exercises can help you practice and develop your skills in implementing and
analyzing the efficiency of divide-and-conquer algorithms for specific problems,
developing new divide-and-conquer algorithms for complex problems and evaluating
their efficiency and effectiveness, and comparing and contrasting divide-and-conquer
algorithms with other algorithmic approaches.



Unit-3: Dynamic Programming:
C/Python /Flowchart
31. Implement the Fibonacci sequence using dynamic programming in C or Python.
Analyze the time complexity of your implementation and compare it with the time
complexity of a recursive implementation.
32. Implement the longest common subsequence problem using dynamic programming
in C or Python. Analyze the time and space complexity of your implementation and
compare it with the time and space complexity of a naive recursive implementation.
33. Implement the knapsack problem using dynamic programming in C or Python.
Analyze the time and space complexity of your implementation and compare it with the
time and space complexity of a greedy algorithm.
34. Implement the rod-cutting problem using dynamic programming in C or Python.
Analyze the time and space complexity of your implementation and compare it with the
time and space complexity of a naive recursive implementation.
35. Implement the matrix chain multiplication problem using dynamic programming in
C or Python. Analyze the time and space complexity of your implementation and
compare it with the time and space complexity of a naive recursive implementation.
36. Develop a dynamic programming algorithm for the edit distance problem in C or
Python. Analyze the time and space complexity of your implementation and compare it
with the time and space complexity of a naive recursive implementation.
37. Develop a dynamic programming algorithm for the coin change problem in C or
Python. Analyze the time and space complexity of your implementation and compare it
with the time and space complexity of a greedy algorithm.
38. Implement a dynamic programming algorithm to find the maximum sum subarray
in C or Python. Analyze the time and space complexity of your implementation and
compare it with the time and space complexity of a naive brute-force approach.
39. Develop a dynamic programming algorithm to find the longest increasing
subsequence in C or Python. Analyze the time and space complexity of your
implementation and compare it with the time and space complexity of a brute-force
approach.
40. Create a flowchart for a dynamic programming algorithm that solves the longest
common substring problem. Analyze the time and space complexity of the algorithm and
compare it with the time and space complexity of a brute-force approach.
These exercises will help you understand and implement dynamic programming
algorithms, analyze their time and space complexity, and compare them with other
algorithmic approaches.



Unit-4: Greedy Algorithms:
C/Python /Flowchart
41. Implement the Huffman coding algorithm to compress a given string in C or Python.
42. Implement Kruskal's algorithm to find the minimum spanning tree of a given graph
in C or Python.
43. Implement the Dijkstra algorithm to find the shortest path between two vertices in a
graph in C or Python.
44. Implement the activity selection problem using a greedy approach in C or Python.
45. Implement the knapsack problem using a greedy approach in C or Python.
46. Implement the coin change problem using a greedy approach in C or Python.
47. Develop a new greedy algorithm to solve the job scheduling problem and analyze its
efficiency and effectiveness in C or Python.
48. Implement Prim's algorithm to find the minimum spanning tree of a given graph in
flowchart.
49. Implement the interval scheduling problem using a greedy approach in flowchart.
50. Implement the fractional knapsack problem using a greedy approach in flowchart.
These exercises will help you practice implementing and analyzing the efficiency of
greedy algorithms for specific problems, developing new greedy algorithms for complex
problems, and comparing and contrasting greedy algorithms with other algorithmic
approaches.



Unit-5: Graph Algorithms:
C/Python /Flowchart
51. Implement Breadth First Search (BFS) algorithm to find the shortest path between
two nodes in a graph in C or Python.
52. Implement Depth First Search (DFS) algorithm to traverse a graph and find
connected components in C or Python.
53. Implement Dijkstra's algorithm to find the shortest path between two nodes in a
weighted graph in C or Python.
54. Implement Bellman-Ford algorithm to find the shortest path between two nodes in a
graph with negative weight edges in C or Python.
55. Implement the Floyd-Warshall algorithm to find the shortest path between all pairs
of nodes in a graph in C or Python.
56. Implement the Prim's algorithm to find the minimum spanning tree of a given graph
in C or Python.
57. Develop a new graph algorithm to solve the traveling salesman problem and
evaluate its efficiency and effectiveness in C or Python.
58. Implement the PageRank algorithm to rank web pages in a network in Python.
59. Implement the Girvan-Newman algorithm to find communities in a social network in
Python.
60. Apply graph algorithms to analyze the network structure and connectivity of a
real-world social network, such as Facebook or Twitter.
These exercises will help you practice implementing and analyzing the efficiency of
graph algorithms for specific problems, developing new graph algorithms for complex
problems, and applying graph algorithms to real-world problems such as network
analysis and social network analysis.



Unit-6 :NP-Completeness:
C/Python /Flowchart
61. Implement a dynamic programming algorithm for the Longest Common
Subsequence Problem (LCS), and analyze its time and space complexity using Big-O
notation.
62. Develop a greedy algorithm for the Job Scheduling Problem, and evaluate its
effectiveness on a variety of input instances.
63. Implement a branch and bound algorithm for the Traveling Salesman Problem, and
analyze its running time complexity.
64. Develop an approximation algorithm for the Set Cover Problem, and analyze its
approximation ratio and running time complexity.
65. Implement a genetic algorithm for the Knapsack Problem, and evaluate its
performance on a set of large-scale instances.
66. Develop a local search algorithm for the Maximum Cut Problem, and compare its
performance to that of a randomized algorithm on a set of random graphs.
67. Implement a randomized algorithm for the Vertex Cover Problem, and analyze its
expected running time using probabilistic techniques.
68. Develop an approximation algorithm for the Steiner Tree Problem, and analyze its
approximation ratio and running time complexity.
69. Implement a simulated annealing algorithm for the Graph Coloring Problem, and
evaluate its performance on a set of benchmark instances.
70. Develop a heuristic algorithm for the Maximum Clique Problem, and compare its
performance to that of the exact algorithm on a set of benchmark instances.
71. Implement a brute force algorithm for the Traveling Salesman Problem (TSP), and
analyze its time complexity using Big-O notation.
72. Develop an approximation algorithm for the Vertex Cover Problem, and evaluate its
effectiveness on a variety of input graphs.
73. Implement a greedy algorithm for the Knapsack Problem, and analyze its
approximation ratio.
74. Develop a heuristic algorithm for the Maximum Clique Problem, and compare its
performance to that of the exact algorithm on a set of benchmark instances.
75. Implement a randomized algorithm for the Subset Sum Problem, and analyze its
expected running time using probabilistic techniques.
76. Develop a genetic algorithm for the Quadratic Assignment Problem, and evaluate its
performance on a set of large-scale instances.
77. Implement a local search algorithm for the Graph Coloring Problem, and compare its
performance to that of a randomized algorithm on a set of randomly generated graphs.
78. Develop an approximation algorithm for the Set Cover Problem, and analyze its
approximation ratio and running time complexity.
79. Implement a simulated annealing algorithm for the Traveling Salesman Problem,
and evaluate its performance on a set of benchmark instances.
80. Develop a tabu search algorithm for the Maximum Cut Problem, and compare its
performance to that of a greedy algorithm on a set of random graphs.


The questions are numbered accordingly.
